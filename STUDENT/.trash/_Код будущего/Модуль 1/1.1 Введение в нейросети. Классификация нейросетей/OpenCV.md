
**OpenCV (Open Source Computer Vision Library)** — это библиотека программного обеспечения для компьютерного зрения и машинного обучения с открытым исходным кодом.

OpenCV предоставляет инструменты для задач компьютерного зрения, включая обнаружение и распознавание объектов, но не имеет встроенной нейронной сети. Однако его можно использовать с популярными платформами глубокого обучения, такими как TensorFlow и Caffe, для создания и обучения нейронных сетей задачам компьютерного зрения. Чтобы работать с нейронной сетью в OpenCV, вам необходимо интегрировать выбранную вами среду глубокого обучения в ваш проект OpenCV, а затем использовать ее API для создания, обучения и запуска нейронной сети.

После того, как вы интегрировали среду глубокого обучения и построили свою нейронную сеть, вы можете использовать алгоритмы компьютерного зрения OpenCV для предварительной обработки входных данных и передачи их в нейронную сеть. После того, как нейронная сеть обработала данные, вы можете использовать OpenCV для постобработки вывода и отображения результатов.

Важно отметить, что обучение нейронной сети может потребовать больших вычислительных ресурсов и больших объемов данных. Вам также может потребоваться тонкая настройка архитектуры сети и гиперпараметров для достижения хороших результатов.

Кроме того, стоит отметить, что использование предварительно обученных моделей часто может сэкономить вам много времени и ресурсов по сравнению с обучением собственной модели с нуля. Многие фреймворки глубокого обучения имеют предварительно обученные модели, доступные для популярных задач компьютерного зрения, которые можно точно настроить для вашего конкретного случая использования или использовать как есть. Это может быть особенно полезно для задач, в которых может не хватать данных для обучения собственной модели, или для задач, в которых предварительно обученная модель уже обучена на большом и разнообразном наборе данных, что обеспечивает более высокую точность.

В целом, использование OpenCV с нейронной сетью — мощный инструмент для решения задач компьютерного зрения, и при правильном понимании и ресурсах можно добиться впечатляющих результатов. Независимо от того, решите ли вы использовать предварительно обученные модели или обучать свои собственные с нуля, сочетание OpenCV и глубокого обучения обеспечивает гибкое и мощное решение для многих приложений компьютерного зрения.

**Чтение изображения с камеры**
```python
import cv2 
import numpy as np 

cap = cv2.VideoCapture(0) 
while True: 
res, img=cap.read() 
cv2.imshow('image', img)

# Обработчик событий для выхода из цикла при нажатии клавиши "q".

if cv2.waitKey(1) & 0xFF == ord('q'): 
break  

# Для освобождения ресурсов камеры. 
cap.release() 
# Для закрытия всех окон OpenCV при завершении программы. cv2.destroyAllWindows()
``` 

**Цветовые пространства**  

Теперь попробуем перевести изображение в другое цветовое пространство, например, HSV. Для этого в OpenCV есть функция cv2.cvtColor(). Она принимает как минимум два параметра: исходное изображение и константу, указывающую, какое преобразование следует произвести. Эти константы начинаются с cv2.COLOR_ и содержат описание преобразования (например, cv2.COLOR_RGB2HLS).

Важный момент: по умолчанию OpenCV использует цветовое пространство BGR, и изображения, захваченные с камеры, закодированы именно так. Следовательно, для перевода в пространство HSV надо использовать константу cv2.COLOR_BGR2HSV.

```python
import cv2 
import numpy as np 
cap=cv2.VideoCapture(0) 
while True: 
	res, img=cap.read() 
	cv2.imshow('image', img) 
	img_hsv=cv2.cvtColor(img, cv2.COLOR_BGR2HSV) 
	hue=img_hsv[:,:,0] 
	saturation=img_hsv[:,:,1] 
	value=img_hsv[:,:,2] 
	cv2.imshow('hue', hue) 
	cv2.imshow('saturation', saturation) 
	cv2.imshow('value', value)  
	
	# Обработчик событий для выхода из цикла при нажатии клавиши "q". 
	if cv2.waitKey(1) & 0xFF == ord('q'): 
		break 
# Для освобождения ресурсов камеры. 
cap.release() 

# Для закрытия всех окон OpenCV при завершении программы. 
cv2.destroyAllWindows()  
```

![[Pasted image 20240201092821.png]]

Рисунок 8. Изменяем цветовое пространство

**Центр области**

Наконец, вычислим «центр масс» белой области на финальном изображении. Для этого воспользуемся функцией cv2.moments(), высчитывающей различные «моменты» изображения (нам потребуются статические моменты) Подробнее о том, как они считаются, можно почитать в документации OpenCV.

Коротко: момент m00 – просто сумма значений пикселей; m01 – статический момент относительно оси y, m10 – статический момент относительно оси x. Центр масс будет в точке (m10 / m00, m01 / m00) - всё как в физике.

```python
import cv2
import numpy as np

cap=cv2.VideoCapture(0)
while True:
res, img=cap.read()
img_hsv=cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
color_low1= (0, 100, 100)
color_high1= (15, 255, 255)

color_low2= (165, 100, 100)
color_high2= (180, 255, 255)

img_thresh1=cv2.inRange(img_hsv, color_low1, color_high1)
img_thresh2=cv2.inRange(img_hsv, color_low2, color_high2)
img_thresh=cv2.bitwise_or(img_thresh1, img_thresh2)

cv2.imshow('img_thresh', img_thresh)
moments=cv2.moments(img_thresh)
# Вполне возможно, что ничего в наш диапазон не попало.
# В этом случае момент `m00` будет равен нулю, и делить
# на него нельзя. Учтём это в наших расчётах.
if moments["m00"] !=0.0:
# Для рисования круга вокруг центра масс нам нужны
# целочисленные координаты, поэтому результат деления
# приводим к целым:
cnt_x=int(moments["m10"] /moments["m00"])
cnt_y=int(moments["m01"] /moments["m00"])
# Рисуем окружность на исходном изображении. Параметры:
# img - исходное изображение,
# (cnt_x, cnt_y) - координаты центра окружности,
# 10 - радиус окружности,
# (0, 255, 0) - цвет круга (B=0, G=255, R=0 - зелёный)
# 3 - толщина линии окружности
img=cv2.circle(img, (cnt_x, cnt_y), 10, (0, 255, 0), 3)
cv2.imshow('image', img)

if cv2.waitKey(13) >0:
break
```

![[Pasted image 20240201093042.png]]

Рисунок 9. Нахождения центра области

**Обвод лица квадратом**

```python
face_cascade_db = cv2.CascadeClassifier(cv2.data.haarcascades + "haarcascade_frontalface_default.xml")

cap = cv2.VideoCapture(0)

while True:

    success, img = cap.read()

    #img = cv2.imread("IMG_20191012_145410_3.jpg")

    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

 

    faces = face_cascade_db.detectMultiScale(img_gray, 1.1, 19)

    for (x,y,w,h) in faces:

        cv2.rectangle(img, (x,y), (x+w,y+h), (0,255,0),2)

 

    cv2.imshow('rez', img)

    #cv2.waitKey()

    if cv2.waitKey(1) & 0xff == ord('q'):

        break


cap.release()

cv2.destroyAllWindows()
```

![[Pasted image 20240201093152.png]]

Рисунок 10. Распознавание лица

**Нахождение глаз**

```python
face_cascade_db = cv2.CascadeClassifier(cv2.data.haarcascades+"haarcascade_frontalface_default.xml")

eye_cascade = cv2.CascadeClassifier(cv2.data.haarcascades+"haarcascade_eye.xml")

cap = cv2.VideoCapture(0)

while True:

    success, img = cap.read()

    #img = cv2.imread("IMG_20191012_145410_3.jpg")

    img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    faces = face_cascade_db.detectMultiScale(img_gray, 1.1, 19)

    for (x,y,w,h) in faces:

        cv2.rectangle(img, (x,y), (x+w,y+h), (0,255,0), 2)

        img_gray_face = img_gray[y:y+h,x:x+w]

        eyes = eye_cascade.detectMultiScale(img_gray_face, 1.1, 19)

        for (ex, ey, ew, eh) in eyes:

            cv2.rectangle(img, (x+ex, y+ey), (x+ex + ew, y+ey + eh), (255, 0, 0), 2)

    cv2.imshow('rez', img)

    if cv2.waitKey(1) & 0xff == ord('q'):

        break

cap.release()

cv2.destroyAllWindows()
```

![[Pasted image 20240201093343.png]]

Рисунок 11. Нахождение глаз

В заключение следует сказать, что использование OpenCV с нейронной сетью может стать отличным способом объединить мощь компьютерного зрения и глубокого обучения.

С помощью правильных инструментов и ресурсов вы можете обучать нейронные сети решать сложные задачи машинного зрения, такие как обнаружение объектов, сегментация и классификация. Ключ в том, чтобы понять, как использовать OpenCV и выбранную вами среду глубокого обучения для создания, обучения и запуска нейронной сети. Это может потребовать крутой кривой обучения, но результаты могут того стоить, поскольку нейронные сети оказались очень эффективными для многих задач компьютерного зрения.
#МоиЛекции #ЯзыкПрограммирования #Python 

При выполнении скрипта на языке Python все выполнение в общем случае разбивается на две стадии:

1. Файл с кодом (файл с расширением `.py`) компилируется в промежуточный байт-код.

2. Далее скомпилированный байт-кодом интерпретируется, то есть происходит собственно выполнение программы

При этом нам не надо явным образом генерировать никакой байт-код, он создается неявно при выполнении скрипта Python. Если программа импортирует внешние модули/библиотеки и они импортируются первый раз, то их скомпилированный байт-код сохраняется сохраняется в файле с расширением `.pyc` и кэшируется в каталоге `__pycache__` в папке, где расположен файл с кодом python. Если мы вносим в исходный файл библиотеки изменения, то Python перекомпилирует файл байт-кода. Если изменений в коде нет, то загружается ранее скомпилированный байт-код из файла `*.pyc`. Это позволяет оптимизировать работу с приложением, быстрее его компилировать и выполнять.

Однако байт-код основного скрипта, который представляет основной файл программы и который передается интерпретатору python, не сохраняется в файле `*.pyc` и перекомпилируется каждый раз при запуске приложения.

Допустим, в папке проекта у нас размещен файл `user.py` со простейшей функцией, которая принимает два параметра и выводит их значения:

```python
def printUser(username, userage):
    print(f"Name: {username}  Age:{userage}")
```

Подключим этот файл в главном модуле программы, который пусть называется `app.py`:

```python
import user
username = "Tom"
userage = 39
 
user.printUser(username, userage)
```

При выполнении этого скрипта в папке проекте (где располагается модуль "`user.py`") будет создан каталог `__pycache__`. А в нем будет сгенерирован файл байт-кода, который будет наподобие следующего `user.cpython-версия.pyc`, где в качестве версии будет применяться версия используемого интерпретатора, например, 311 (для версии Python 3.11). Сгенерированный `pyc`-файл является бинарным, поэтому текстовом редакторе нет смысла его открывать.

![[Pasted image 20240909093113.png]]

### Ручная компиляция байт-кода

Хотя файл байт-кода создается автоматически, мы вручную можем его сгенерировать. Для этого есть несколько способов: компиляция с помощью скрипта `py_compile` и компиляция с помощью модуля `compileall`.

Скрипт `py_compile` применяется для компиляции отдельных файлов. Для компиляции произвольного скрипта user.py в файл с байт-кодом мы могли бы использовать следующую программу:

```python
import py_compile
 
py_compile.compile("user.py")   # передаем путь к скрипту
```

Для компиляции в функцию `compile()` передаем путь к скрипту. После выполнения программы в текущей папке также будет сгенерирован каталог `__pycache__`, а в нем файл `user.cpython-311.pyc`

Модуль `compileall` применяется для компиляции всех файлов Python по определенным путям. Например, скомпилируем все файлы в каталоге `C:/python/files`

```
python -m compileall c:\python\files
```

По умолчанию компилируются даже те файлы, которые содержатся в подкаталогах. Если надо скомпилировать только те файлы, которые располагаются непосредственно в указанно папке, то применяется опция `-l`

```
python -m compileall c:\python\files -l
```

---
## Ссылки

1. [Генерация байткода модулей](https://metanit.com/python/tutorial/6.6.php)

---

| [[Определение и подключение модулей\|Предыдущая лекция]] | [[Модуль random\|Следующая лекция]] |
| -------------------------------------------------------- | ----------------------------------- |

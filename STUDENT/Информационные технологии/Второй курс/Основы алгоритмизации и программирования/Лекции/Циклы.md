#МоиЛекции #ЯзыкПрограммирования #Python 

Циклы позволяют выполнять некоторое действие в зависимости от соблюдения некоторого условия. В языке Python есть следующие типы циклов:

- **while**
- **for**

### Цикл while

Цикл while проверяет истинность некоторого условия, и если условие истинно, то выполняет инструкции цикла. Он имеет следующее формальное определение:

```python
while условное_выражение:
   инструкции
```

После ключевого слова **while** указывается условное выражение, и пока это выражение возвращает значение `True`, будет выполняться блок инструкций, который идет далее.

Все инструкции, которые относятся к циклу **while**, располагаются на последующих строках и должны иметь отступ от начала ключевого слова **while**.

```python
number = 1
 
while number < 5:
    print(f"number = {number}")
    number += 1
print("Работа программы завершена")
```

В данном случае цикл **while** будет выполняться, пока переменная `number` меньше `5`.

Сам блок цикла состоит из двух инструкций:

```python
print(f"number = {number}")
number += 1
```

Обратите внимание, что они имеют отступы от начала оператора **while** - в данном случае от начала строки. Благодаря этому Python может определить, что они принадлежат циклу. В самом цикле сначала выводится значение переменной number, а потом ей присваивается новое значение. .

Также обратите внимание, что последняя инструкция `print("Работа программы завершена")` не имеет отступов от начала строки, поэтому она не входит в цикл **while**.

Весь процесс цикла можно представить следующим образом:

1. Сначала проверяется значение переменной `number` - меньше ли оно `5`. И поскольку вначале переменная равна `1`, то это условие возвращает `True`, и поэтому выполняются инструкции цикла. Инструкции цикла выводят на консоль строку `number = 1`. И далее значение переменной `number` увеличивается на единицу - теперь она равна `2`. Однократное выполнение блока инструкций цикла называется итерацией. То есть таким образом, в цикле выполняется первая итерация.

2. Снова проверяется условие `number < 5`. Оно по прежнему равно `True`, так как `number = 2`, поэтому выполняются инструкции цикла. Инструкции цикла выводят на консоль строку `number = 2`. И далее значение переменной `number` опять увеличивается на единицу - теперь она равна `3`. Таким образом, выполняется вторая итерация.

3. Опять проверяется условие `number < 5`. Оно по прежнему равно `True`, так как `number = 3`, поэтому выполняются инструкции цикла. Инструкции цикла выводят на консоль строку `number = 3`. И далее значение переменной `number` опять увеличивается на единицу - теперь она равна `4`. То есть выполняется третья итерация.

4. Снова проверяется условие `number < 5`. Оно по прежнему равно `True`, так как `number = 4`, поэтому выполняются инструкции цикла. Инструкции цикла выводят на консоль строку `number = 4`. И далее значение переменной `number` опять увеличивается на единицу - теперь она равна `5`. То есть выполняется четвертая итерация.

5. И вновь проверяется условие `number < 5`. Но теперь оно равно False, так как `number = 5`, поэтому выполняются выход из цикла. Все цикл - завершился. Дальше уже выполняются действия, которые определены после цикла. Таким образом, данный цикл произведет четыре прохода или четыре итерации.

В итоге при выполнении кода мы получим следующий консольный вывод:

```python
number = 1
number = 2
number = 3
number = 4
Работа программы завершена
```

Для цикла **while** также можно определить дополнительный блок **else**, инструкции которого выполняются, когда условие равно **False**:

```python
number = 1
 
while number < 5:
    print(f"number = {number}")
    number += 1
else:
    print(f"number = {number}. Работа цикла завершена")
print("Работа программы завершена")
```

То есть в данном случае сначала проверяется условие и выполняются инструкции **while**. Затем, когда условие становится равным **False**, выполняются инструкции из блока **else**. Обратите внимание, что инструкции из блока **else** также имеют отступы от начала конструкции цикла. В итоге в данном случае мы получим следующий консольный вывод:

```python
number = 1
number = 2
number = 3
number = 4
number = 5 # Работа цикла завершена
# Работа программы завершена
```

Блок **else** может быть полезен, если условие изначально равно `False`, и мы можем выполнить некоторые действия по этому поводу:

```python
number = 10
 
while number < 5:
    print(f"number = {number}")
    number += 1
else:
    print(f"number = {number}. Работа цикла завершена")
print("Работа программы завершена")
```

В данном случае условие `number < 5` изначально равно `False`, поэтому цикл не выполняет ни одной итерации и сразу переходит в блоку **else**.

### Цикл for

Другой тип циклов представляет конструкция **for**. Этот цикл пробегается по набору значений, помещает каждое значение в переменную, и затем в цикле мы можем с этой переменной производить различные действия. Формальное определение цикла **for**:

```python
for переменная in набор_значений:
    инструкции
```

После ключевого слова **for** идет название переменной, в которую будут помещаться значения. Затем после оператора **in** указывается набор значений и двоеточие.

А со следующей строки располагается блок инструкций цикла, которые также должны иметь отступы от начала цикла.

При выполнении цикла Python последовательно получает все значения из набора и передает их переменную. Когда все значения из набора будут перебраны, цикл завершает свою работу.

В качестве набора значений, например, можно рассматривать строку, которая по сути представляет набор символов. Посмотрим на примере:

```python
message = "Hello"
 
for c in message:
    print(c)
```

В цикле определяется переменную `c`, после оператора `in` в качестве перебираемого набора указана переменная message, которая хранит строку `"Hello"`. В итоге цикл **for** будет перебирает последовательно все символы из строки `message` и помещать их в переменную `c`. Блок самого цикла состоит из одной инструкции, которая выводит значение переменной с на консоль. Консольный вывод программы:

```python
H
e
l
l
o
```

Нередко в связке с циклом **for** применяется встроенная функция `range()`, которая генерирует числовую последовательность:

```python
for n in range(10):
    print(n, end=" ")
```

Если функцию range передается один параметр, то он означает максимальное значение диапазона чисел. В данном случае генерируется последовательность от `0` до `10` (не включительно). В итоге мы получим следующий консольный вывод:

```
0 1 2 3 4 5 6 7 8 9
```

Также в функцию `range()` можно передать минимальное значение диапазона

```python
for n in range(4, 10):
    print(n, end=" ")
```

Здесь генерируется последовательность от `4` до `10` (не включая). Консольный вывод:

```
4 5 6 7 8 9
```

Также в функцию `range()` можно передать третий параметр, который указывает на приращение:

```python
for n in range(0, 10, 2):
    print(n, end=" ")
```

Здесь генерируется последовательность от `0` до `10` (не включая) с приращением `2`. Консольный вывод:

```
0 2 4 6 8
```

Цикл **for** также может иметь дополнительный блок **else**, который выполняется после завершения цикла:

```python
message = "Hello"
for c in message:
    print(c)
else:
    print(f"Последний символ: {c}. Цикл завершен");
print("Работа программы завершена")  # инструкция не имеет отступа, поэтому не относится к else
```

В данном случае мы получим следующий консольный вывод:

```
H
e
l
l
o
Последний символ: o. Цикл завершен
Работа программы завершена
```

Стоит отметить, что блок **else** имеет доступ ко всем переменным, которые определены в цикле **for**.

### Вложенные циклы

Одни циклы внутри себя могут содержать другие циклы. Рассмотрим на примере вывода таблицы умножения:

```python
i = 1
j = 1
while i < 10:
    while j < 10:
        print(i * j, end="\t")
        j += 1
    print("\n")
    j = 1
    i += 1
```

Внешний цикл `while i < 10:` срабатывает 9 раз пока переменная `i` не станет равна `10`. Внутри этого цикла срабатывает внутренний цикл `while j < 10:`. Внутренний цикл также срабатывает 9 раз пока переменная `j` не станет равна `10`. Причем все 9 итераций внутреннего цикла срабатывают в рамках одной итерации внешнего цикла.

В каждой итерации внутреннего цикла на консоль будет выводится произведение чисел `i` и `j`. Затем значение переменной `j` увеличивается на единицу. Когда внутренний цикл закончил работу, значений переменной `j` сбрасывается в `1`, а значение переменной `i` увеличивается на единицу и происходит переход к следующей итерации внешнего цикла. И все повторяется, пока переменная `i` не станет равна 10. Соответственно внутренний цикл сработает всего 81 раз для всех итераций внешнего цикла. В итоге мы получим следующий консольный вывод:

```
1	2	3	4	5	6	7	8	9	

2	4	6	8	10	12	14	16	18	

3	6	9	12	15	18	21	24	27	

4	8	12	16	20	24	28	32	36	

5	10	15	20	25	30	35	40	45	

6	12	18	24	30	36	42	48	54	

7	14	21	28	35	42	49	56	63	

8	16	24	32	40	48	56	64	72	

9	18	27	36	45	54	63	72	81
```

Подобным образом можно определять вложенные циклы **for**:

```python
for c1 in  "ab":
    for c2 in "ba":
        print(f"{c1}{c2}")
```

В данном случае внешний цикл проходит по строке `"ab"` и каждый символ помещает в переменную `c1`. Внутренний цикл проходит по строке `"ba"`, помещает каждый символ строки в переменную `c2` и выводит сочетание обоих символов на консоль. То есть в итоге мы получим все возможные сочетания символов `a` и `b`:

```
ab
aa
bb
ba
```

### Выход из цикла. break и continue

Для управления циклом мы можем использовать специальные операторы **break** и **continue**. Оператор **break** осуществляет выход из цикла. А оператор **continue** выполняет переход к следующей итерации цикла.

Оператор **break** может использоваться, если в цикле образуются условия, которые несовместимы с его дальнейшим выполнением. Рассмотрим следующий пример:

```python
number = 0
while number < 5:
    number += 1
    if number == 3 :    # если number = 3, выходим из цикла
        break
    print(f"number = {number}")
```

Здесь цикл **while** проверяет условие `number < 5`. И пока `number` не равно `5`, предполагается, что значение number будет выводиться на консоль. Однако внутри цикла также проверяется другое условие: `if number == 3`. То есть, если значение `number` равно `3`, то с помощью оператора **break** выходим из цикла. И в итоге мы получим следующий консольный вывод:

```
number = 1
number = 2
```

В отличие от оператора `break` оператор **continue** выполняет переход к следующей итерации цикла без его завершения. Например, в предыдущем примере заменим **break** на continue:

```python
number = 0
while number < 5:
    number += 1
    if number == 3 :    # если number = 3, переходим к новой итерации цикла
        continue
    print(f"number = {number}")
```

И в этом случае если значение переменной `number` равно `3`, последующие инструкции после оператора **continue** не будут выполняться:

```
number = 1
number = 2
number = 4
number = 5
```

---
## Домашнее задание

![[Задание. Циклы]]

---
## Ссылки

1. [Metanit. Циклы](https://metanit.com/python/tutorial/2.7.php)
2. [[Вопросы для самопроверки. Циклы]]

---

| [[Условная конструкция if\|Предыдущая лекция]] | [[Функции\|Следующая лекция]] |
| ---------------------------------------------- | ----------------------------- |




#МоиЛекции #ЯзыкПрограммирования  #Python

Модуль в языке Python представляет отдельный файл с кодом, который можно повторно использовать в других программах.

Для создания модуля необходимо создать собственно файл с расширением `*.py`, который будет представлять модуль. Название файла будет представлять название модуля. Затем в этом файле надо определить одну или несколько функций.

Допустим, основной файл программы называется `main.py`. И мы хотим подключить к нему внешние модули.

Для этого сначала определим новый модуль: создадим в той же папке, где находится `main.py`, новый файл, который назовем `message.py`. По умолчанию интерпретатор Python ищет модули по ряду стандартных путей, один из которых – это папка главного, запускаемого скрипта. Поэтому, чтобы интерпретатор подхватил модуль` message.py`, для простоты оба файла поместим в один проект.

![[Pasted image 20240831215859.png]]

Соответственно модуль будет называться `message`. Определим в нем следующий код:

```python
hello = "Hello all"
 
 
def print_message(text):
    print(f"Message: {text}")
```

Здесь определена переменная `hello` и функция `print_message`, которая в качестве параметра получает некоторый текст и выводит его на консоль.

В основном файле программы – `main.py` используем данный модуль:

```python
import message      # подключаем модуль message
 
# выводим значение переменной hello
print(message.hello)        # Hello all
# обращаемся к функции print_message
message.print_message("Hello work")  # Message: Hello work
```

Для использования модуля его надо импортировать с помощью оператора `import`, после которого указывается имя модуля: `import message`.

Чтобы обращаться к функциональности модуля, нам нужно получить его пространство имен. По умолчанию оно будет совпадать с именем модуля, то есть в нашем случае также будет называться `message`.

Получив пространство имен модуля, мы сможем обратиться к его функциям по схеме `пространство_имен.функция`

Например, обращение к функции `print_message()` из модуля `message`:

```python
message.print_message("Hello work")
```

И после этого мы можем запустить главный скрипт `main.py`, и он задействует модуль `message.py`. В частности, консольный вывод будет следующим:

```
Hello all
Message: Hello work
```

### Подключение функциональности модуля в глобальное пространство имен

Другой вариант настройки предполагает импорт функциональности модуля в глобальное пространство имен текущего модуля с помощью ключевого слова `from`:

```python
from message import print_message
 
# обращаемся к функии print_message из модуля message
print_message("Hello work")  # Message: Hello work
 
# переменная hello из модуля message не доступна, так как она не импортирована
# print(message.hello)   
# print(hello) 
```

В данном случае мы импортируем из модуля `message` в глобальное пространство имен функцию `print_message()`. Поэтому мы сможем ее использовать без указания пространства имен модуля как если бы она была определена в этом же файле.

Все остальные функции, переменные из модуля недоступны (как например, в примере выше переменная `hello`). Если мы хотим их также использовать, то их можно подключить по отдельности:

```python
from message import print_message
from message import hello
 
# обращаемся к функции print_message из модуля message
print_message("Hello work")  # Message: Hello work
 
# обращаемся к переменной hello из модуля message
print(hello)    # Hello all
```

Если необходимо импортировать в глобальное пространство имен весь функционал, то вместо названий отдельных функций и переменных можно использовать символ звёздочки `*`:

```python
from message import *
 
# обращаемся к функции print_message из модуля message
print_message("Hello work")  # Message: Hello work
 
# обращаемся к переменной hello из модуля message
print(hello)    # Hello all
```

Но стоит отметить, что импорт в глобальное пространство имен чревато коллизиями имен функций. Например, если у нас в том же файле определена функция с тем же именем до ее вызова, то будет вызываться функция, которая определена последней:

```python
from message import *
  
print_message("Hello work")  # Message: Hello work - применяется функция из модуля message
 
def print_message(some_text):
    print(f"Text: {some_text}")
  
print_message("Hello work")  # Text: Hello work - применяется функция из текущего файла
```

Таким образом, одноименная функция текущего файла скрывает функцию из подключенного модуля.

### Установка псевдонимов

При импорте модуля и его функциональности мы можем установить для них псевдонимы. Для этого применяется ключевое слово as, после которого указывается псевдоним. Например, установим псевдоним для модуля:

```python
import message as mes  # модуль message проецируется на псевдоним mes
 
# выводим значение переменной hello
print(mes.hello)        # Hello all
# обращаемся к функии print_message
mes.print_message("Hello work")  # Message: Hello work
```

В данном случае пространство имен будет называться `mes`, и через этот псевдоним можно обращаться к функциональности модуля.

Подобным образом можно установить псевдонимы для отдельной функциональности модуля:

```python
from message import print_message as display
from message import hello as welcome
 
print(welcome)          # Hello all - переменная hello из модуля message
display("Hello work")   # Message: Hello work - функция print_message из модуля message
```

Здесь для функции `print_message` из модуля message устанавливается псевдоним `display`, а для переменной `hello` – псевдоним `welcome`. И через эти псевдонимы мы сможем к ним обращаться.

Псевдонимы могут быть полезны, когда нас не устраивают имена функций и переменных, например, они слишком длинные, и мы хотим их сократить, либо мы хотим дать им более описательные, с нашей точки зрения, имена. Либо если в текущем файле уже есть функциональность с теми же именами, и с помощью установки псевдонимов мы можем избежать конфликта имен. Например:

```python
from message import print_message as display
 
def print_message(some_text):
    print(f"Text: {some_text}")
 
# функция print_message из модуля message
display("Hello work")       # Message: Hello work
 
# функция print_message из текущего файла
print_message("Hello work")  # Text: Hello work
```

### Имя модуля

В примере выше модуль `main.py`, который является главным, использует модуль `message.py`. При запуске модуля `main.py` программа выполнит всю необходимую работу. Однако, если мы запустим отдельно модуль `message.py` сам по себе, то ничего на консоли не увидим. Ведь модуль `message` просто определяет функцию и переменную и не выполняет никаких других действий. Но мы можем сделать так, чтобы модуль `message.py` мог использоваться как сам по себе, так и подключаться в другие модули.

При выполнении модуля среда определяет его имя и присваивает его глобальной переменной `__name__` (с обеих сторон по два подчеркивания). Если модуль является запускаемым, то его имя равно `__main__` (также по два подчеркивания с каждой стороны). Если модуль используется в другом модуле, то в момент выполнения его имя аналогично названию файла без расширения `py`. И мы можем это использовать. Так, изменим содержимое файла `message.py`:

```python
hello = "Hello all"
 
 
def print_message(text):
    print(f"Message: {text}")
 
 
def main():
    print_message(hello)
 
 
if __name__ == "__main__": 
    main()
```

В данном случае в модуль` message.py` для тестирования функциональности модуля добавлена функция `main`. И мы можем сразу запустить файл `message.py` отдельно от всех и протестировать код.

Следует обратить внимание на вызов функции `main`:

```python
if __name__ == "__main__":
    main()
```

Переменная `__name__` указывает на имя модуля. Для главного модуля, который непосредственно запускается, эта переменная всегда будет иметь значение `__main__` вне зависимости от имени файла.

Поэтому, если мы будем запускать скрипт `message.py` отдельно, сам по себе, то Python присвоит переменной `__name__` значение `__main__`, далее в выражении `if` вызовет функцию `main` из этого же файла.

Однако если мы будем запускать другой скрипт, а этот – message.py – будем подключать в качестве вспомогательного, для message.py переменная `__name__` будет иметь значение `message`. И соответственно метод `main` в файле `message.py` не будет работать.

Данный подход с проверкой имени модуля является более рекомендуемым подходом, чем просто вызов метода `main`.

В файле `main.py` также можно сделать проверку на то, является ли модуль главным (хотя в принципе это необязательно):

```python
import message
 
 
def main(): 
    message.print_message("Hello work")  # Message: Hello work
 
 
if __name__ == "__main__":
    main()
```

Python предоставляет ряд встроенных модулей, которые мы можем использовать в своих программах. В следующих статьях рассмотрим основные из них.

---
## Ссылки

1. [Модули](https://metanit.com/python/tutorial/2.10.php)

---

| [[Упаковка и распаковка в параметрах функций\|Предыдущая лекция]] | [[Генерация байт-кода модулей\|Следующая лекция]] |
| ----------------------------------------------------------------- | ------------------------------------------------- |

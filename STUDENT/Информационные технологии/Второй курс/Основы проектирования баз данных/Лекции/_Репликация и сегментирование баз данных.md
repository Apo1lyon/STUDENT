#МоиЛекции #БД 

**Репликация** - это процесс, который включает обмен информацией для обеспечения согласованности между избыточными ресурсами, такими как несколько баз данных, для повышения надежности, отказоустойчивости или доступности.
## Репликация Master-Slave

Ведущее устройство (**Master**) обслуживает операции чтения и записи, реплицируя записи одному или нескольким подчиненным устройствам (**Slave**), которые обслуживают только операции чтения. Подчиненные устройства также могут реплицировать дополнительные подчиненные устройства древовидным способом. Если ведущее устройство переходит в автономный режим, система может продолжать работать в режиме только для чтения до тех пор, пока ведомое устройство не будет переведено в ведущее устройство или не будет подготовлен новый ведущий.

![[Pasted image 20240228090438.png]]
### Преимущества

- Резервное копирование всей базы данных практически не влияет на работу мастера.
- Приложения могут считывать данные с ведомого устройства (устройств), не влияя на ведущее устройство.
- Подчиненные устройства можно перевести в автономный режим и синхронизировать обратно с ведущим без каких-либо простоев.

### Недостатки

- Репликация увеличивает количество оборудования и усложняет работу.
- Время простоя и, возможно, потеря данных при сбое основного устройства.
- Все записи также должны выполняться мастером в архитектуре "master-slave".
- Чем больше подчиненных устройств для чтения, тем больше нам приходится реплицировать, что увеличивает задержку репликации.

## Master-Master-репликация

Оба мастера выполняют операции чтения / записи и координируют их друг с другом. Если какой-либо из мастеров выходит из строя, система может продолжать работать как с операциями чтения, так и с операциями записи.

![[Pasted image 20240228091704.png]]

### Преимущества

- Приложения могут читать оба мастера.
- Распределяет нагрузку на запись между обоими главными узлами.
- Простой, автоматический и быстрый переход на другой ресурс.

### Недостатки

- Настроить и развернуть master-master не так просто, как **master-slave**.
- Либо слабо согласован, либо имеет увеличенную задержку записи из-за синхронизации.
- Разрешение конфликтов вступает в игру по мере добавления большего количества узлов записи и увеличения времени ожидания.

### Синхронная репликация против асинхронной

Основное различие между синхронной и асинхронной репликацией заключается в том, как данные записываются в реплику. При синхронной репликации данные записываются в основное хранилище и в реплику одновременно. Таким образом, основная копия и реплика всегда должны оставаться синхронизированными.

В отличие от этого, асинхронная репликация копирует данные в реплику после того, как данные уже записаны в основное хранилище. Хотя процесс репликации может происходить практически в режиме реального времени, чаще всего репликация выполняется по расписанию, и это более экономично.

---
## Сегментирование баз данных

**Сегментирование базы данных** - это метод распределения данных по нескольким машинам. Это метод горизонтального масштабирования, в отличие от вертикального масштабирования, которое заключается в увеличении мощности одной машины. 

> **Сегментирование** - распространенный способ масштабирования базы данных.

**Секционирование данных** - это метод разделения базы данных на множество более мелких частей. Это процесс разделения базы данных или таблицы на нескольких компьютерах для улучшения управляемости, производительности и доступности базы данных.

Существует множество различных способов, которыми можно воспользоваться, чтобы решить, как разбить базу данных приложения на несколько БД меньшего размера. Ниже приведены три наиболее популярных метода, используемых различными крупномасштабными приложениями:

**Горизонтальное разделение (или сегментирование)**

В рамках этой стратегии мы разбиваем данные таблицы по горизонтали на основе диапазона значений, определяемого _ключом раздела_. Это также называется **_сегментированием базы данных_**.

**Вертикальное разделение**

При вертикальном разделении мы разделяем данные по вертикали на основе столбцов. Мы разделяем таблицы на относительно небольшие таблицы с небольшим количеством элементов, и каждая часть представлена в отдельном разделе.

В этом руководстве мы специально сосредоточимся на сегментировании.

---
## Что такое сегментирование?

**Сегментирование** - это шаблон архитектуры базы данных, связанный с _горизонтальным секционированием_, которое представляет собой практику разделения строк одной таблицы на несколько разных таблиц, известных как _разделы_ или _сегменты_. Каждый раздел имеет одинаковую схему и столбцы, но также и подмножество общих данных. Аналогично, данные, хранящиеся в каждом из них, уникальны и независимы от данных, хранящихся в других разделах.

![[Pasted image 20240228094702.png]]

Обоснование сегментирования данных заключается в том, что после определенного момента дешевле и выполнимее масштабировать по горизонтали, добавляя больше машин, чем масштабировать по вертикали, добавляя мощные серверы. Сегментирование может быть реализовано как на уровне приложения, так и на уровне базы данных.

---
## Критерии разделения

Для разделения данных доступно большое количество критериев. Вот некоторые наиболее часто используемые критерии::

### На основе хэша

Эта стратегия разделяет строки на разные разделы на основе алгоритма хеширования, а не группирует строки базы данных на основе непрерывных индексов.

Недостатком этого метода является то, что динамическое добавление / удаление серверов баз данных становится дорогостоящим.

### На основе списков

При разделении на основе списков каждый раздел определяется и выбирается на основе списка значений в столбце, а не набора смежных диапазонов значений.

### На основе диапозона

Разбиение на диапазоны отображает данные в различные разделы на основе диапазонов значений ключа разбиения. Другими словами, мы разбиваем таблицу таким образом, чтобы каждый раздел содержал строки в пределах заданного диапазона, определенного ключом разбиения.

Диапазоны должны быть смежными, но не перекрывающимися, где каждый диапазон определяет не включающую нижнюю и верхнюю границы раздела. Любые значения ключей секционирования, равные или превышающие верхнюю границу диапазона, добавляются в следующий раздел.

### Композитный

Как следует из названия, составное разделение разделяет данные на основе двух или более методов разделения. Здесь мы сначала разделяем данные, используя один метод, а затем каждый раздел дополнительно подразделяется на подразделы, используя тот же или какой-либо другой метод.

## Преимущества

Но зачем нам нужен сегмент? Вот несколько преимуществ:

- **Доступность**: Обеспечивает логическую независимость разделенной базы данных, обеспечивая высокую доступность нашего приложения. Здесь отдельными разделами можно управлять независимо.
- **Масштабируемость**: Доказано, что повышает масштабируемость за счет распределения данных по нескольким разделам.
- **Безопасность**: Помогает повысить безопасность системы за счет хранения конфиденциальных и неконфликтных данных в разных разделах. Это может обеспечить лучшую управляемость и безопасность конфиденциальных данных.
- **Производительность запросов**: Повышает производительность системы. Вместо того, чтобы запрашивать всю базу данных, теперь системе приходится запрашивать только меньший раздел.
- **Управляемость данными**: разделяет таблицы и индексы на более мелкие и более управляемые блоки.

## Недостатки

- **Сложность**: Сегментирование увеличивает сложность системы в целом.
- **Объединения по сегментам**: После того, как база данных разделена и распределена по нескольким машинам, часто невозможно выполнять объединения, охватывающие несколько сегментов базы данных. Такие объединения не будут эффективны с точки зрения производительности, поскольку данные необходимо извлекать с нескольких серверов.
- **Перебалансировка**: Если распределение данных неравномерно или на один сегмент приходится большая нагрузка, в таких случаях нам приходится перебалансировать наши сегменты, чтобы запросы распределялись между сегментами как можно более равномерно.

## Когда использовать сегментирование?

Вот несколько причин, по которым сегментирование может быть правильным выбором:

- Использование существующего оборудования вместо высокопроизводительных машин.
- Ведение данных в различных географических регионах.
- Быстрое масштабирование за счет добавления дополнительных сегментов.
- Повышается производительность, поскольку каждая машина подвергается меньшей нагрузке.
- Когда требуется больше одновременных подключений.

---
## Ссылки

[Системный дизайн](https://dev.to/karanpratapsingh/system-design-the-complete-course-10fo#sharding)
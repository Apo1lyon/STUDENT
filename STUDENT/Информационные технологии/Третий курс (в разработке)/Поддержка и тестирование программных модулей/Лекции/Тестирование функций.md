#МоиЛекции #ЯзыкПрограммирования #Python #QA 

Чтобы потренироваться в тестировании, нам понадобится код. Создадим программу и дадим ей имя `name_function.py`. Ниже приведена простая функция, которая получает имя и фамилию и возвращает отформатированное полное имя:

```python
def get_formatted_name(first, last): 
	"""Строит отформатированное полное имя.""" 
	full_name = f"{first} {last}" 
	return full_name.title()
```

Функция `get_formatted_name()` строит полное имя из имени и фамилии, разделив их пробелом, преобразует первый символ каждого слова к верхнему регистру и возвращает полученный результат. Чтобы убедиться в том, что функция `get_ formatted_name()` работает правильно, мы напишем программу, использующую эту функцию. Программа `names.py` запрашивает у пользователя имя и фамилию и выдает отформатированное полное имя:

```python
from name_function import get_formatted_name 

print("Введите 'q' для выхода из программы.") 
while True: 
	first = input("\nВведите имя: ") 
	if first == 'q': 
		break 
	last = input("Введите фамилию: ")
	if last == 'q': 
		break 
		
	formatted_name = get_formatted_name(first, last) 
	print(f"\tПолное имя: {formatted_name}.")
```

Программа импортирует функцию `get_formatted_name()` из модуля `name_function py`. Пользователь вводит последовательность имен и фамилий и видит, что программа сгенерировала отформатированные полные имена:

```
Введите 'q' для выхода из программы.

Введите имя: janis 
Введите фамилию: joplin 
	Полное имя: Janis Joplin. 

Введите имя: bob 
Введите фамилию: dylan 
	Полное имя: Bob Dylan.
	
Введите имя: q
```

Как видно из листинга, имена сгенерированы правильно. 

Но допустим, вы решили изменить функцию `get_formatted_name()`, чтобы она также работала со вторыми именами. При этом необходимо проследить за тем, чтобы функция не перестала правильно работать для имен, состоящих только из имени и фамилии. Чтобы про- тестировать код, можно запустить `names.py` и для проверки вводить имя из двух компонентов (скажем, `Janis Joplin`) при каждом изменении `get_formatted_name()`, но это довольно утомительно. 

К счастью, Python, как мы говорили выше, предоставляет эффективный механизм автоматизации тестирования вывода функций. При автоматизации тестирования `get_formatted_name()` вы будете уверены в том, что функция успешно работает для всех видов имен, для которых написаны тесты.

### Модульные тесты и тестовые сценарии 

Модуль `unittest` из стандартной библиотеки Python предоставляет функциональность для тестирования вашего кода. Модульный тест проверяет правильность работы одного конкретного аспекта поведения функции. Тестовый сценарий представляет собой совокупность модульных тестов, которые совместно доказывают, что функция ведет себя так, как положено, во всем диапазоне ситуаций, которые она должна обрабатывать. Хороший тестовый сценарий учитывает все возможные виды ввода, которые может получать функция, и включает тесты для представления всех таких ситуаций. Тестовый сценарий с полным покрытием включает полный спектр модульных тестов, покрывающих все возможные варианты использования функции. Обеспечение полного покрытия для крупного проекта может быть весьма непростой задачей. Часто бывает достаточно написать модульные тесты для кри- тичных аспектов поведения вашего кода, а затем стремиться к полному покрытию только в том случае, если проект перейдет в фазу масштабного использования.

---
## Ссылки

1. [[Изучаем_Python_Программирование.pdf#page=222&selection=2,0,2,12|Изучаем_Python_Программирование, страница 222]]

---

| [[Тестирование в Python. Что такое unittest\|Предыдущая лекция]] | [[Тестирование классов\|Следующая лекция]] |
| ---------------------------------------------------------------- | ------------------------------------------ |

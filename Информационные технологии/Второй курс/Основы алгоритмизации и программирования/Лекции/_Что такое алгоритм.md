#МоиЛекции  #Алгоритмизация 

**Алгоритм** — это четкая последовательность действий, выполнение которой дает какой-то заранее известный результат. 

Простыми словами, это набор инструкций для конкретной задачи. Известнее всего этот термин в информатике и компьютерных науках, где под ним понимают инструкции для решения задачи эффективным способом.

Само слово «*алгоритм*» не раскрывает своего значения в полной мере. Оно происходит от имени Мухаммада ибн Мусы аль-Хорезми (ок. 783 — ок. 850), персидского ученого, который работал в областях математики, астрономии и географии. Аль-Хорезми внес большой вклад во многие сферы науки.

![[Pasted image 20240530173632.png | 500]]

 Имя Аль-Хорезми в латинском варианте выглядит как *Algorismus*; его стали использовать для обозначения численных методов с десятичными числами. Впоследствии термин *Algorismus* под влиянием греческого слова *arithmos* (ἀριθμός — число) превратился в *algorithm* (алгоритм) и все так же обозначал десятичную арифметику, пока в девятнадцатом веке не обзавелся современным значением.

Многие думают, что алгоритмы имеют какое-то отношение к компьютерам, но это не так. Они существовали задолго до появления компьютеров. Первый алгоритм, о котором нам известно, существовал еще во времена древнего Вавилона. Кроме того, алгоритмы решают не компьютерные проблемы. Они описывают, что и как нужно делать, в виде последовательности шагов.

> **Алгоритм** — это определенный способ решения задачи, который можно описать в виде простых шагов и затем выполнить на компьютере с поразительной скоростью и эффективностью. 

---
## Понимание работы алгоритмов на примерах

Начнем наше знакомство с алгоритмами с задачи, которую можно решить вручную.

Представьте, что у нас *есть два множества объектов и мы хотим как можно равномернее распределить объекты одного множества среди объектов другого*. Объекты в первом множестве будут обозначаться как `×`, а во втором — как `•`. Мы хотим распределить крестики между точками.

Если количество крестиков точно делится на количество точек, все просто: крестики между точками достаточно разместить так, как будто мы выполняем деление. Например, *если всего у нас 12 объектов, из которых три — это крестики, а остальные девять — точки, мы рисуем один крестик, затем три точки, затем один крестик, затем три точки и, наконец, еще один крестик и три точки.*

```× • • • × • • • × • • •```

Но что, если общее количество объектов *нельзя* точно разделить на число крестиков? Что, если крестиков у нас пять, а точек семь? Вначале мы *размещаем в один ряд все крестики и затем все точки*, как показано ниже:

`× × × × × • • • • • • •`

После этого помещаем пять точек снизу от крестиков:

```
× × × × × • •
• • • • • 
```

В результате справа остаются два столбца с одной точкой в каждом. *Поместим их под двумя первыми столбцами, образуя третью строку*:

```
× × × × × 
• • • • • 
• • 
```

Теперь можно *заметить три оставшихся столбца*. *Два из них (крайние справа) помещаем под двумя первыми столбцами*:

```
× × × 
• • • 
• • 
× × 
• •
```

Остается всего один лишний столбец, поэтому мы останавливаемся. *Объединим столбцы, перемещаясь слева направо*, и получим:

`× • • × • × • • × • × •`

Это наш результат. Мы распределили крестики между точками. Не так равномерно, как раньше, но это закономерно, ведь, как вы помните, пять не делится ровно на 12. Тем не менее мы избежали нагромождения крестиков и создали последовательность, которая не выглядит совсем уж бессистемной.

---
## Свойства алгоритмов

К основным свойствам алгоритмов относятся следующие свойства:

1. **Понятность для исполнителя.** Исполнитель алгоритма должен понимать, как его выполнять. Иными словами, имея алгоритм и произвольный вариант исходных данных, исполнитель должен знать, как надо действовать для выполнения этого алгоритма.

2. **Дискретность (прерывность, раздельность).** Алгоритм должен представлять процесс решения задачи как последовательное выполнение простых (или ранее определенных) шагов (этапов).

3. **Определенность.** Каждое правило алгоритма должно быть четким, однозначным и не оставлять места для произвола.

Благодаря этому свойству выполнение алгоритма носит механический характер и не требует никаких дополнительных указаний или сведений о решаемой задаче.

4. **Релевантность** (или конечность) состоит в том, что за конечное число шагов алгоритм либо должен приводит к решению задачи, либо после конечного числа шагов останавливаться из-за невозможности получить решение с выдачей соответствующего сообщения, либо неограниченно продолжаться в течение времени, отведенного для исполнения алгоритма, с выдачей промежуточных результатов.

5. **Массовость** означает, что алгоритм решения задачи разрабатывается в общем виде, т.е. он должен быть применим для некоторого класса задач, различающихся лишь исходными данными. При этом исходные данные могут выбираться из некоторой области, которая называется областью применимости алгоритма.
---
## Правила построения алгоритма

Чтобы алгоритм выполнил свое предназначение, eго необходимо строить по определенным правилам. В этом смысле нужно говорить не о свойствах алгоритма, а о правилах построения алгоритма, или о требованиях, предъявляемых к алгоритму.

**Первое правило.** При построении алгоритма, прежде всего, *необходимо задать множество объектов*, с которыми будет работать алгоритм. Формализованное (закодированное) представление этих объектов носит название *данных*. Алгоритм приступает к работе с некоторым набором данных, которые называются *входными*, и в результате своей работы выдает данные, которые называются *выходными*. Таким образом, алгоритм преобразует входные данные в выходные.

Это правило позволяет сразу отделить алгоритмы от "методов" и “способов”. Пока мы не имеем формализованных входных данных, мы не можем построить алгоритм.

**Второе правило**. *Для работы алгоритма требуется память*. В памяти размещаются входные данные, с которыми алгоритм начинает работать, промежуточные данные и выходные данные, которые являются результатом работы алгоритма. *Память является дискретной, т.е. состоящей из отдельных ячеек*. Поименованная ячейка памяти носит название *переменной*. В теории алгоритмов размеры памяти не ограничиваются, т. е. считается, что мы можем предоставить алгоритму любой необходимый для работы объем памяти.

**Третье правило**. *Дискретность*. Алгоритм строится из отдельных шагов (действий, операций, команд). Множество шагов, из которых составлен алгоритм, конечно.

**Четвертое правило**. *Детерменированность*. После каждого шага необходимо указывать, какой шаг выполняется следующим, либо давать команду остановки.

**Пятое правило**. *Сходимость (результативность)*. Алгоритм должен завершать работу после конечного числа шагов. При этом необходимо указать, что считать результатом работы алгоритма.

Итак, алгоритм ─ неопределяемое понятие теории алгоритмов. Алгоритм каждому определенному набору входных данных ставит в соответствие некоторый набор выходных данных, т. е. вычисляет (реализует) функцию. При рассмотрении конкретных вопросов в теории алгоритмов всегда имеется в виду какая-то конкретная модель алгоритма.

---
## Ссылки

1. [[Основы алгоритмизации.pdf]]
2. [Лекция. Основные понятия алгоритмизации](https://studfile.net/preview/7423495/page:7/)

| [[_Виды форм записи алгоритмов\|Следующая лекция]] |
| -------------------------------------------------- |




#МоиЛекции #ЯзыкПрограммирования #Python 

### Встроенные типы исключений

В примерах предыдущей лекции обрабатывались сразу все исключения, которые могут возникнуть в коде. Однако мы можем конкретизировать тип обрабатываемого исключения, указав его после слова `except`:

```python
try:
    number = int(input("Введите число: "))
    print("Введенное число:", number)
except ValueError:
    print("Преобразование прошло неудачно")
print("Завершение программы")
```

В данном случае блок `except` обрабатывает только исключения типа `ValueError`, которые могут возникнут при неудачном преобразовании строки в число.

В Python есть следующие базовые типы исключений:

- **BaseException**: базовый тип для всех встроенных исключений;
- **Exception**: базовый тип, который обычно применяется для создания своих типов исключений;
- **ArithmeticError**: базовый тип для исключений, связанных с арифметическими операциями (*OverflowError*, *ZeroDivisionError*, *FloatingPointError*);
- **BufferError**: тип исключения, которое возникает при невозможности выполнить операцию с буфером;
- **LookupError**: базовый тип для исключений, которое возникают при обращении в коллекциях по некорректному ключу или индексу (например, *IndexError*, *KeyError*).

От этих классов наследуются все конкретные типы исключений. В Python обладает довольно большим списком встроенных исключений. Весь этот список можно посмотреть в [документации](https://docs.python.org/3/library/exceptions.html). Перечислим только некоторые наиболее часто встречающиеся:

- **IndexError**: исключение возникает, если индекс при обращении к элементу коллекции находится вне допустимого диапазона;
- **KeyError**: возникает, если в словаре отсутствует ключ, по которому происходит обращение к элементу словаря;
- **OverflowError**: возникает, если результат арифметической операции не может быть представлен текущим числовым типом (обычно типом `float`);
- **RecursionError**: возникает, если превышена допустимая глубина рекурсии;
- **TypeError**: возникает, если операция или функция применяется к значению недопустимого типа;
- **ValueError**: возникает, если операция или функция получают объект корректного типа с некорректным значением;
- **ZeroDivisionError**: возникает при делении на ноль;
- **NotImplementedError**: тип исключения для указания, что какие-то методы класса не реализованы;
- **ModuleNotFoundError**: возникает при при невозможности найти модуль при его импорте директивой `import`;
- **OSError**: тип исключений, которые генерируются при возникновении ошибок системы (например, невозможно найти файл, память диска заполнена и т.д.).

И если ситуация такова, что в программе могут быть сгенерированы различные типы исключений, то мы можем их обработать по отдельности, используя дополнительные выражения `except`. И при возникновении исключения Python будет искать нужный блок except, который обрабатывает данный тип исключения:

```python
try:
    number1 = int(input("Введите первое число: "))
    number2 = int(input("Введите второе число: "))
    print("Результат деления:", number1/number2)
except ValueError:
    print("Преобразование прошло неудачно")
except ZeroDivisionError:
    print("Попытка деления числа на ноль")
except BaseException:
    print("Общее исключение")
print("Завершение программы")
```

Если возникнет исключение в результате преобразования строки в число, то оно будет обработано блоком `except ValueError`. Если же второе число будет равно нулю, то есть будет деление на ноль, тогда возникнет исключение *ZeroDivisionError*, и оно будет обработано блоком `except ZeroDivisionError`.

Тип *BaseException* представляет общее исключение, под которое попадают все исключительные ситуации. Поэтому в данном случае любое исключение, которое не представляет тип *ValueError* или *ZeroDivisionError*, будет обработано в блоке `except BaseException:`.

Однако, если в программе возникает исключение типа, для которого нет соответствующего блока `except`, то программа не сможет найти соответствующий блок `except` и сгенерирует исключение. Например, в следующем случае:

```python
try:
    number1 = int(input("Введите первое число: "))
    number2 = int(input("Введите второе число: "))
    print("Результат деления:", number1/number2)
except ZeroDivisionError:
    print("Попытка деления числа на ноль")
print("Завершение программы")
```

Здесь предусмотрена обработка деления на ноль с помощью блока `except ZeroDivisionError`. Однако если пользователь вместо числа введет неконвертируемое число в строку, то возникнет исключение типа *ValueError*, для которого нет соответствующего блока `except`. И поэтому программа аварийно завершит свое выполнение.

Python позволяет в одном блоке `except` обрабатывать сразу несколько типов исключений. В этом случае все типы исключения передаются в скобках:

```python
try:
    number1 = int(input("Введите первое число: "))
    number2 = int(input("Введите второе число: "))
    print("Результат деления:", number1/number2)
except (ZeroDivisionError, ValueError):    #  обработка двух типов исключений - ZeroDivisionError и ValueError
    print("Попытка деления числа на ноль или некорректный ввод")
 
print("Завершение программы")
```

### Получение информации об исключении

С помощью оператора `as` мы можем передать всю информацию об исключении в переменную, которую затем можно использовать в блоке `except`:

```python
try:
    number = int(input("Введите число: "))
    print("Введенное число:", number)
except ValueError as e:
    print("Сведения об исключении", e)
print("Завершение программы")
```

Пример некорректного ввода:

```
Введите число: fdsf
Сведения об исключении invalid literal for int() with base 10: 'fdsf'
Завершение программы
```

---
## Ссылки

1. [Except и обработка разных типов исключений](https://metanit.com/python/tutorial/2.20.php)

---

| [[Конструкция try...except...finally\|Предыдущая лекция]] | [[Генерация исключений и создание своих типов исключений\|Следующая лекция]] |
| --------------------------------------------------------- | ---------------------------------------------------------------------------- |
